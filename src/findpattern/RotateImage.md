[[D-matrix]]

# 1 借助辅助数组（⾮原地）
这道题目不难想出旋转所需的操作
```java
matrix[i][j] = matrix[n - 1- i][n - 1 - j];
```

移动一个位置之后目标位置数字就会被覆盖，必须原地排序的话，这一点会造成困难。

# 2 ⽤翻转代替旋转
[[D-matrix#顺时针旋转]]

因为翻转的代码实现比较简洁，可以利用旋转与翻转的关系，使用多次翻转代替旋转。

# 标准原地旋转
## 替换方法
矩阵，所以每次替换是4个一组顺时针相互替换。
```java
private void swap(int[][] a, int i1, int j1, int i2, int j2, int i3, int j3, int i4, int j4) {  
	int tmp = a[i1][j1];  
	a[i1][j1] = a[i4][j4];  
	a[i4][j4] = a[i3][j3];  
	a[i3][j3] = a[i2][j2];  
	a[i2][j2] = tmp;  
}
```
这里不容易想到，不过理解难度并不大

## 遍历方法
有了替换的方法，题目的另一个难点在于，如何用替换方法一圈一圈向内遍历。
在纸上画一画找找规律，我们可以得到`(i,j) - (j,n - 1 - i)`这个规律，即对于一组`i,j`每一圈的数字是：
```java
i1 = i, j1 = j,
i2 = j1, j2 = n - 1 - i1,
i3 = j2, j3 = n - 1 - i2,
i4 = j3, j4 = n - 1 - i3;
```

在纸上怎么画呢，可以画出两组结果（实际的数），从一组中找规律，发现之后用另一组验证。

有了上面的想法，其实已经可以实现顺指针旋转，即 j++。当 j + 1 等于这一圈的长度时，我们让i++进入内圈。

```java
public void rotate(int[][] matrix) {
	int n = matrix.length;
	// size 随着遍历深入会不断减小
	int i = 0, j = 0, size = n - 1;
	while (i < n / 2) {
		// 画图得出
		int i1 = i, j1 = j,
				i2 = j1, j2 = n - 1 - i1,
				i3 = j2, j3 = n - 1 - i2,
				i4 = j3, j4 = n-1-i3;
		// System.out.println(size + " "+i1 + " " + j1 + " " + i2 + " " + j2 + " " + i3 + " " + j3 + " " + i4 + " " + j4);
		swap(matrix, i1, j1, i2, j2, i3, j3, i4, j4);
		if (j + 1 >= size) {
			i++;
			j = i;
			size--;
		} else {
			j++;
		}
	}
}

private void swap(int[][] a, int i1, int j1, int i2, int j2, int i3, int j3, int i4, int j4) {  
	int tmp = a[i1][j1];  
	a[i1][j1] = a[i4][j4];  
	a[i4][j4] = a[i3][j3];  
	a[i3][j3] = a[i2][j2];  
	a[i2][j2] = tmp;  
}
```



# 拓展

1. `n*n`的⼆维矩阵，沿上下中线翻转、沿左右中线翻转
2. `n*n`的⼆维矩阵，沿左上-右下对⻆线翻转、沿左下-右上对⻆线翻转
3. `n*n`的⼆维矩阵，旋转90度、180度、270度
4. `n*m`的⼆维矩阵，沿上下中线翻转、沿左右中线翻转
5. `n*m`的⼆维矩阵，沿左上-右下对⻆线翻转、沿左下-右上对⻆线翻转（⽆法实现）
6. `n*m`的⼆维矩阵，旋转 王争的算法训练营 90度、180度、270度 （需要重新申请新的存储数组）