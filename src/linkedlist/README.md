# 定义

**链表**不需要连续的内存空间，通过指针将一组零散的内存串联起来使用。内存块称为链表的**结点**，为了将结点串起来，结点除了存储数据data外，还需要记录下一个结点的地址，这个记录下一个结点地址的指针叫做**后继指针next**。（即结点由数据域和指针域构成）

第一个和最后一个结点是比较特殊的，分别是头结点和尾结点。头结点用来记录链表的基地址；尾结点的后继指针指向空地址null。


## Singly/Doubly/Circular

单链表只有一个方向，尾结点指向空地址。循环链表是一种特殊的单链表，即尾结点的后继指针指向头结点。

双向链表比单链表多一个前驱指针prev，指向前面结点的地址。支持双向遍历。

当然相应的也有双向循环链表。

java中的LinkedHashMap就用到了双向链表。

虽然双向链表占用多一点内存空间，但是空间换时间很多情况下是值得的。
双向链表的相对优势：一些情况下插入和删除都更高效，因为它支持以O(1)找到前驱结点。

## Delete/Add

删除操作 ：

1. 删除结点中值等于指定值的结点 
   不管是单项还是双向，都需要从头遍历 O（n）
2. 删除已知指向的结点 
   删除后需要知道被删除结点的前驱结点是谁，修改它的后继指针，此时单向链表无法直接知道，需要耗费O(n)去找，双向就不用，O(1)即可。

插入操作 :

1. 插入指定排序的位置
   需要遍历
2. 插入已知结点后
   直接插入
3. 插入已知结点前
   双向链表没有问题，单项链表存在不知道前驱是谁的问题，需要从头遍历

> 除删除和插入，对于有序链表，双向链表在查找时更具优势，可以选择向前还是向后找。

## Sentinel Node 哨兵结点

A sentinel is a dummy object that allows us to simplify boundary conditions.

A sentinel node is a dummy node that goes at the front of a list. 
In a doubly-linked list, the sentinel node points to the first and last elements of the list. 

单链表在插入和删除时，需要修改**前驱结点的后继指针**，这就形成了“邻居依赖”，链表中第一个元素没有前驱结点，如果没有特殊处理在插入和删除第一个结点时，就会出错。

head 表示头结点指针，指向第一个结点，head == null表示是空链表。

### 带头链表

引入哨兵结点，不管链表是否为空，head指针都指向一个哨兵结点，我们把这种链表叫做带头链表。


# 数组与链表的取舍

实际开发当中，不能简单的用复杂度分析来决定使用哪种数据结构。

如数组使用的是连续内存，可以CPU缓存机制可以预读数组中的数据，访问效率更高，但是链表的离散存储对CPU的缓存机制就不是很友好，无法高效预读。（CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块，并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入）

数组的缺陷是大小固定，申请太大不一定有，申请太小扩容很麻烦。
链表本身没有大小限制。

对内存的使用要求苛刻应多使用数组，链表除了需要额外的存储空间去存放指针，频繁的插入删除还会导致频繁的内存申请和释放，造成内存随便，触发gc。


## Java ArrayList

ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。还有一个优势，就是支持动态扩容

当然动态扩容是比较耗时和消耗资源的，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。

不过扩容时如果连续内存不够，就需要开辟新的更大的空间并且拷贝已有数据，效率很差。

相对来说更应**使用数组而不是ArrayList**的场景：

1. ArrayList不能存储基本类型，比如 int、long，需要封装为 Integer、Long类，Autoboxing、Unboxing 会有一定的性能消耗。追求性能应使用数组
2. 如果事先已知数据的大小，使用数组十分简便，arrayList的大部分方法并不会用到。
3. 表示多维数据时，数组更加直观
4. 其他链表的缺点：额外内存存放指针、频繁删除插入容易产生随便引发GC

比如 Object[][] array
用容器的话则ArrayList<ArrayList> array

业务开发使用容器省时省力，使用ArrayList就足够了。如果是做底层，则要考虑使用数组而不是容器。

> Q&A 为什么大多数语言数组下标要从0开始？

从内存模型可知，下标的实际含义是偏移（offset）。
a来表示数组的首地址，a[0]则表示偏移为0，计算a[k]的地址根据偏移寻址时使用如下公式

```
a[k]_address = base_address + k * type_size

```

从上述公式的type_size可以了解为什么数组只能存放同一种数据类型
若使用1做地址，则要多做一次-1 减法。

当然，还有就是历史原因，C是以0开始的。上述理由并不是绝对，尤其不同编程语言，比如python还支持负数下标。

btw二维数组寻址对于m*n的数组 a [ i ][ j ] (i < m,j < n)

```
address = base_address + ( i * n + j) * type_size
```


# 必须掌握的编程问题

## 一些技巧

1. 理解指针或引用的含义
   含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。
   示例：
   p—>next = q; 表示p节点的后继指针存储了q节点的内存地址。
   p—>next = p—>next—>next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。

2. 警惕丢失指针和内存泄露
   插入第一个/删除最后一个
3. 利用哨兵简化问题
   减少特殊情况及相应的判断
4. 重点留意边界条件处理
   - 链表为空
   - 只包含一个结点
   - 只包含两个结点
   - 处理头/尾结点，别在插入、删除后丢掉了头/尾

5. 画图举例，辅助思考
6. 多写多练，没有捷径
   孰能生巧，不管是什么算法，只有经过反复的练习，才能信手拈来。

java 反转链表的操作：
```
Collections.reverse(list);
```
