纯栈排序很容易想到，偏简单。提高效率的惰性更新更有意思。

维护一个有序的栈，即每次push和pop操作前后，栈都应该是有序的
每次push前，将栈中元素比当前小的push到辅助栈中，完成后再push回来；每次pop只需将当前栈顶元素pop出来即可。
题目本身不难，也没有太多绕的地方。

不过上面的实现效率并不高， 有没有继续优化的可能？

# 惰性更新
连续多次push时，需要多次把元素在两个栈中传递。想象这样一个极端情况： 连续n次push相同或相近元素，需要来回操作2n x i次，其中i为每次移动的元素数量。
实际上，我们只需要移动2 x i次：先把i个元素移到辅助栈，再把n个元素放入栈，最后将辅助栈中元素移回来即可。
此为惰性更新

惰性更新策略运用很广泛，比如著名的U&F算法、区间树等，就使用了此策略。


排序栈也可以理解为优先级栈