对于「任何表达式」而言，我们都使用两个栈 nums 和 ops：
- nums ： 存放所有的数字
- ops ：存放所有的数字以外的操作

然后从前往后做，对遍历到的字符做分情况讨论：

- `空格` : 跳过
- `数字 `: 从当前位置开始继续往后取，将整一个连续数字整体取出，加入 nums
- `( `: 直接加入 ops 中，等待与之匹配的`)`
- `) `: 使用现有的 nums 和 ops 进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums
- `+ - * / ^ % `: 需要将操作放入 ops 中。在放入之前先把栈内可以算的都算掉
**重点在这里**，**只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算**，使用现有的 nums 和 ops 进行计算，直到没有操作或者遇到左括号，计算结果放到 nums



一些corner case：
-  由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 `nums` 添加一个 0
	- 对于`(` 之后同样是一个开头
- 从理论上分析，nums 最好存放的是 long，而不是 int。因为可能存在 大数 + 大数 + 大数 + … - 大数 - 大数 的表达式导致中间结果溢出，最终答案不溢出的情况
