# 概念

堆是一个完全二叉树；

堆中的每一个结点的值都必须大于等于（大顶堆）/小于等于（小顶堆）其**子树**中每个结点的值。 
-   1和2 大顶堆 3小顶堆 4不是堆
  ![img](272cc3ff-2ede-45d4-a5c3-ed904e4dc399.jpg) 

# 堆的实现
默认以大顶堆描述

## 存储
完全二叉树这种数据结构比较适合使用数组存储。 
数组中下标为`i`的结点的左子结点下标为`i*2`，右子结点下标为`i*2+1`，父结点为下标`i/2`的结点。
- 此处默认数组下标是从1开始
- 若默认为0开始应该是`i`、左`i*2+1`、右`i*2+2`、父`（i/2）-1`

## 堆化
在数组元素变化数据后，要继续满足堆的特性，需要进行调整，我们称为**堆化**heapify。 
堆化有两种，自上而下和从下往上
- 整体的堆化可以理解为一个一个新的插入，通过插入方法进行堆化


### 初始堆化（从下而上）
堆化过程需要注意子结点的覆盖范围

在数组末尾插入一个数据，相对简单，顺着结点所在的路径，向上或向下对比、交换

### 删除堆顶（自上而下）

堆顶元素就是就是最大值/最小值。 
假设我们使用大顶堆，删除堆顶就需要将第二大的结点（从其左右子树中查找）向上替换，直到叶子结点被删除。但这样可能导致堆不满足完全二叉树的定义。 
- 这里的删除会导致堆内的数据量减一

所以要换一种思路，把最后一个结点放到堆顶，然后利用父子结点对比方法，对于不满足的进行互换，直到满足。这就是从上向下的堆化方法。






# 基于堆实现排序
分为两个步骤 建堆和排序。

## 建堆

将数组 原地 建生一个堆。 两种思路：
1. 尽管数组包含n个数据，但我们可以假设堆中只包含一个数据，即下标为一的数据，然后用插入操作将剩余数据都“插入”到堆中。 即从前向后处理数据，从下向上堆化 
2.和第一种思路完全相反。从后往前处理数组，自上而下堆化。 

从下标n/2开始到1的数据开始堆化
- 下标n/2+1到n是叶子结点，不含子节点
![img](6b1f279d-d029-45a6-a1ab-172704ab3f9f.jpg) 
![img](f56b5c04-bf9b-4c0a-97e3-f970d3f9e3f7.jpg) 
每个结点堆化的时间复杂度是O（logn），n/2+1个结点的堆化是O（nlogn），经过推导实际上是O（n）。

## 排序
堆建好之后，数组中的数据已经是按照大顶堆的特性来组织的。排序过程类似删除堆顶元素的过程，当堆顶移除后，把下标为n的元素放到堆顶，然后把剩下的这n-1个元素重新构成堆。一直重复，直到只剩下下标为1的元素。 
排序过程时间复杂度是O（nlogn）

过程中只需要少量的临时存储，因此堆排序属于原地排序。排序的互换操作导致堆排序不是稳定的排序算法。

## 实际开发中为什么偏向快速排序而不是堆排序

- 堆排序的数据访问方式非线性 
  堆排序数据是跳跃访问的，如顶点的堆化可能依次访问 1 2 4 8，而不是像快速排序那样，局部顺序访问。这样对CPU缓存不友好。
  
- 同样的数据，堆排序做的数据交换次数要多于快速排序 
  排序要关注有序度和逆序度 
  对于基于比较的排序，整个过程就是由比较和交换（或移动）两个基本操作构成的。快速排序的交换次数不会比逆序次多。 
  但是堆排序的建堆过程会打乱排序，有序数据经过建堆也会变的无序。

# 堆的应用

### 优先级队列PriorityQueue

队列一般是先进先出，不过优先级队列是按照优先级来，优先级最高的先出。 
堆其实和优先级队列非常相似，一个堆就可以看作一个优先级队列，很多时候只是概念上的区分。 
优先级队列的应用非常广泛，哈夫曼编码/图的最短路径/最小生成树算法等
对应java中的PriorityQueue，C++中的priotity_queue。

### 合并有序小文件

有序合并100个大小为100MB存储有序字符串的文件。

从100个文件中各取一个字符串，放入数组然后比较，将最小的放入大文件中，同时从这个文件中取出下一个字符放到数组中，重新比较大小，依此类推。 
上述方法每次从数组中取最小值都需要遍历整个数组，效率一般。 
使用优先队列效率就会高很多，将取出的字符放入一个小顶堆中，每次取出堆顶，再从文件中取下一个字符放入堆中，循环这个过程。

### 高性能定时器

类似crontab 有很多定时任务，为了看有没有拿个到达执行时间，定时器每隔一段时间（比如1s）都去扫码一遍所有任务显然是效率很低的，多数徒劳，并且列表很大消耗也很大。 
可以按照任务设定的时间把任务存储在优先队列，堆顶存储的任务就是最先将要执行的任务。这样就不用一直扫码，可以用当前时间和堆顶任务相减得到间隔T，这样定时器就知道在T-1秒这段时间不需要做任何事。之后访问也不需要遍历整个列表。很高效。

## TopK
top k问题可以分为动态 / 静态 数据集合两类

#### 静态数据求Top K
[[KthLargestElementInAnArray]]
包含n个数据的数组求k大：维护一个大小为k的**小**顶堆，顺序遍历数组，如果取出的数据比堆顶大，则删除堆顶把这个数据插入，依此类推。遍历完之后堆中的数据就是top k。 
遍历数组O（n），每次堆化O（logK），最坏情况下时间复杂度O（nlogK）


### 利用堆求中位数

中位数，数据个数n为奇数，则是第n/2+1个数据；如果是偶数，则有两个 n/2和n/2+1，这时可以随意选一个。 

对于静态数据可以先排序，直接返回数据，虽然排序代价大，但是多次查询的化边际成本会很小。但是动态数据每次都重新排序效率太差了，借助堆可以不用排序直接实现取中位数。 
维护两个堆，小顶堆的数据都大于大顶堆的数据。如果新加入的数据小于大顶堆的顶，则加入大顶堆；若大于小顶堆的顶则插入小顶堆。然后两个堆通过不断将堆顶元素移入另一个堆来保证数量的平衡。偶数各半，奇数大顶堆多一。 
涉及堆化，时间复杂度是O（logn），但是取中位数只用返回大顶堆的顶元素就可以了 复杂度是O（1）。

不仅可以求中位数，还可以快速求出百分位的数据，原理是类似的。 
如：如何快速求出接口99%的响应时间？ 
用两个堆实现 大顶堆保存`n*0.99` 小顶堆保存`n*0.01`


#### 动态数据求Top K
[[KthLargestElementInAStream]]
实时top K 
如果每次询问前K大的时候进行一次计算，那就和静态数据求K一样，时间复杂度O（nlogK）。我们还可以一直维护着一个K大小的小顶堆，这样每次想知道就可以很快的返回。
- 限制不允许删除、修改数据操作